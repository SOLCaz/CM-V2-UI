{"ast":null,"code":"import { useCallback } from 'react';\nimport { statusFromToken } from '../useReducer/utils';\nimport { getRefreshIntervalMs } from '../config';\nimport logger from '../logger';\nimport { GatewayStatus, RefreshTokenState } from '../types';\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          refreshIntervalId: action.refreshIntervalId,\n          walletToRefresh: action.walletToRefresh,\n          refreshTokenState: RefreshTokenState.CHECK_TOKEN_EXPIRATION\n        });\n      }\n\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          gatewayStatus: GatewayStatus.REFRESH_TOKEN_REQUIRED,\n          refreshTokenState: RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: RefreshTokenState.COMPLETED,\n          gatewayStatus: statusFromToken(state, state.gatewayToken)\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: GatewayStatus.COLLECTING_USER_INFORMATION\n        });\n      }\n\n    case 'refresh_clear_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: undefined\n      });\n\n    case 'refresh_set_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: action.refreshIntervalId\n      });\n\n    default:\n      return state;\n  }\n};\n\nconst useRefresh = ({\n  stage,\n  gatekeeperClient\n}, state, dispatch) => {\n  const {\n    refreshIntervalId,\n    gatewayToken\n  } = state;\n\n  const logDebug = (message, obj = null) => logger.debug(`[useRefresh] ${message}`, obj);\n\n  const logError = (message, obj = null) => logger.error(`[useRefresh] ${message}`, obj);\n  /**\n   * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n   * event, triggering the refreshFlow\n   */\n\n\n  const setRefreshPoll = useCallback(connectedWallet => {\n    if (!refreshIntervalId) {\n      const interval = setInterval(() => {\n        dispatch({\n          type: 'refresh_status_check',\n          refreshIntervalId: interval,\n          walletToRefresh: connectedWallet\n        });\n      }, getRefreshIntervalMs(stage)); // this will be cleared on completion\n      // We need to know that the interval was set even if it has not fired yet.\n      // to avoid setting duplicate intervals.\n\n      dispatch({\n        type: 'refresh_set_interval',\n        refreshIntervalId: interval\n      });\n      logger.debug('setRefreshPoll setInterval', getRefreshIntervalMs(stage));\n    }\n  }, [refreshIntervalId, stage]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  const refreshTokenWithProof = useCallback(useWallet => ({\n    proof,\n    payload\n  }) => {\n    return new Promise((resolve, reject) => {\n      logDebug('Refresh token with proof', proof);\n\n      if (proof && gatewayToken) {\n        dispatch({\n          type: 'refresh_with_powo_in_progress'\n        });\n        gatekeeperClient().refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload).then(() => {\n          resolve();\n        }).catch(error => {\n          logError('Error refreshing token with proof', error);\n          reject(error);\n        });\n      }\n    });\n  }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n  return {\n    setRefreshPoll,\n    refreshTokenWithProof\n  };\n};\n\nexport default useRefresh;","map":{"version":3,"sources":["C:/Users/mikec/candy-machine-v2-responsive-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["useCallback","statusFromToken","getRefreshIntervalMs","logger","GatewayStatus","RefreshTokenState","reducer","state","action","type","Object","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","refreshIntervalId","walletToRefresh","refreshTokenState","CHECK_TOKEN_EXPIRATION","gatewayStatus","REFRESH_TOKEN_REQUIRED","IN_PROGRESS","COMPLETED","gatewayToken","renderIframe","iframeMinimized","COLLECTING_USER_INFORMATION","useRefresh","stage","gatekeeperClient","dispatch","logDebug","message","obj","debug","logError","error","setRefreshPoll","connectedWallet","interval","setInterval","refreshTokenWithProof","useWallet","proof","payload","Promise","resolve","reject","refreshToken","identifier","publicKey","then","catch"],"mappings":"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","sourcesContent":["import { useCallback } from 'react';\nimport { statusFromToken } from '../useReducer/utils';\nimport { getRefreshIntervalMs } from '../config';\nimport logger from '../logger';\nimport { GatewayStatus, RefreshTokenState } from '../types';\nexport const reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: RefreshTokenState.CHECK_TOKEN_EXPIRATION });\n        }\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: RefreshTokenState.COMPLETED, gatewayStatus: statusFromToken(state, state.gatewayToken) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: GatewayStatus.COLLECTING_USER_INFORMATION });\n        }\n        case 'refresh_clear_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });\n        case 'refresh_set_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });\n        default:\n            return state;\n    }\n};\nconst useRefresh = ({ stage, gatekeeperClient }, state, dispatch) => {\n    const { refreshIntervalId, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger.debug(`[useRefresh] ${message}`, obj);\n    const logError = (message, obj = null) => logger.error(`[useRefresh] ${message}`, obj);\n    /**\n     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n     * event, triggering the refreshFlow\n     */\n    const setRefreshPoll = useCallback((connectedWallet) => {\n        if (!refreshIntervalId) {\n            const interval = setInterval(() => {\n                dispatch({\n                    type: 'refresh_status_check',\n                    refreshIntervalId: interval,\n                    walletToRefresh: connectedWallet,\n                });\n            }, getRefreshIntervalMs(stage)); // this will be cleared on completion\n            // We need to know that the interval was set even if it has not fired yet.\n            // to avoid setting duplicate intervals.\n            dispatch({\n                type: 'refresh_set_interval',\n                refreshIntervalId: interval,\n            });\n            logger.debug('setRefreshPoll setInterval', getRefreshIntervalMs(stage));\n        }\n    }, [refreshIntervalId, stage]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshTokenWithProof = useCallback((useWallet) => ({ proof, payload }) => {\n        return new Promise((resolve, reject) => {\n            logDebug('Refresh token with proof', proof);\n            if (proof && gatewayToken) {\n                dispatch({ type: 'refresh_with_powo_in_progress' });\n                gatekeeperClient()\n                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload)\n                    .then(() => {\n                    resolve();\n                })\n                    .catch((error) => {\n                    logError('Error refreshing token with proof', error);\n                    reject(error);\n                });\n            }\n        });\n    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n    return {\n        setRefreshPoll,\n        refreshTokenWithProof,\n    };\n};\nexport default useRefresh;\n"]},"metadata":{},"sourceType":"module"}